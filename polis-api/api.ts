/**
 * Pol.is
 * The Pol.is API for AI-powered conversations.
 *
 * OpenAPI spec version: 3.0.0
 * Contact: foo@example.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://polis-api-proxy.herokuapp.com/api/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class CommentModel {
    'created': number;
    'isSeed': boolean;
    'quoteSrcUrl': string;
    'social': any;
    /**
    * Topic ID?
    */
    'tid': number;
    'tweetId': number;
    'txt': string;
}

export class CommentRequestBody {
    'agid': number;
    'conversationId': string;
    'pid': CommentRequestBody.PidEnum;
    'txt': string;
    'isSeed': boolean;
    'vote': number;
}

export namespace CommentRequestBody {
    export enum PidEnum {
        Mypid = <any> 'mypid'
    }
}
export class ConversationModel {
    /**
    * Conversation title.
    */
    'topic': string;
    /**
    * Conversation description shown above interactive portion. May contain markdown formatting.
    */
    'description': string;
    'isAnon': boolean;
    'isActive': boolean;
    'isPublic': boolean;
    'emailDomain': string;
    'owner': number;
    'participantCount': number;
    /**
    * Milliseconds since Unix epoch.
    */
    'created': number;
    'strictModeration': boolean;
    'profanityFilter': boolean;
    'spamFilter': boolean;
    /**
    * Milliseconds since Unix epoch.
    */
    'modified': number;
    'ownerSeesParticipationStats': boolean;
    'ltiUsersOnly': boolean;
    'linkUrl': string;
    'upvotes': number;
    'parentUrl': string;
    'visType': number;
    'writeType': number;
    'bgcolor': string;
    'helpType': number;
    'socialbtnType': number;
    'authNeededToVote': boolean;
    'authNeededToWrite': boolean;
    'authOptFb': boolean;
    'authOptTw': boolean;
    'authOptAllow3rdparty': boolean;
    'isDataOpen': boolean;
    'isSlack': boolean;
    'siteId': string;
    'authOptFbComputed': boolean;
    'authOptTwComputed': boolean;
    'ownername': string;
    'isMod': boolean;
    'isOwner': boolean;
    'pp': boolean;
    'url': string;
    'modUrl': string;
    'conversationId': string;
}

export class ConversationParticipantStats {
    /**
    * Vote count for individual participant
    */
    'votes': number;
    /**
    * Comment count for individual participant
    */
    'comments': number;
}

export class ConversationParticipants {
    /**
    * Milliseconds since Unix epoch.
    */
    'created': number;
    /**
    * Milliseconds since Unix epoch.
    */
    'lastInteraction': number;
    /**
    * Milliseconds since Unix epoch.
    */
    'lastNotified': number;
    'mod': number;
    /**
    * Participant ID within this conversation context. Often corresponds to index in vectors.
    */
    'pid': number;
    'subscribed': number;
    'uid': number;
    'voteCount': number;
    /**
    * Conversation ID
    */
    'zid': number;
}

export class FamousVoterModel {
    'bid': number;
    'facebook': FamousVoterModelFacebook;
    'isSelf': boolean;
    'pid': number;
    'priority': number;
    'twitter': FamousVoterModelTwitter;
}

export class FamousVoterModelFacebook {
    'fbLink': string;
    'fbName': string;
    'fbPicture': string;
    'fbUserId': number;
    'verified': boolean;
}

export class FamousVoterModelTwitter {
    'followerCount': number;
    'location': string;
    'name': string;
    'profileImageUrlHttps': string;
    'screenName': string;
    'twitterUserId': number;
    'verified': boolean;
}

export class InlineResponse200 {
    /**
    * 
    */
    'conversationId': string;
    /**
    * 
    */
    'url': string;
}

export class InlineResponse2001 {
    /**
    * Topic ID?
    */
    'tid': number;
    'currentPid': number;
}

export class InlineResponse2002 {
    'id': string;
    /**
    * Conversation ID
    */
    'zid': number;
    /**
    * Timestamp of last vote in conversation. Milliseconds since Unix epoch.
    */
    'lastVoteTimestamp': number;
    'ptptstats': PTPTStatsVectors;
}

export class InlineResponse2003 {
    'currentPid': number;
}

/**
* Payload delivered to the metrics endpoint.
*/
export class MetricsPayload {
    'clientTimestamp': number;
    'durs': Array<number>;
    'times': Array<number>;
    'types': Array<number>;
}

/**
* 
*/
export class PCA2Response {
    /**
    * 
    */
    'id': string;
    /**
    * 
    */
    'base-clusters': any;
    /**
    * 
    */
    'consensus': any;
    'group-clusters': Array<any>;
    /**
    * 
    */
    'group-votes': any;
    'in-conv': Array<number>;
    /**
    * Milliseconds since Unix epoch.
    */
    'lastModTimestamp': number;
    /**
    * Milliseconds since Unix epoch.
    */
    'lastVoteTimestamp': number;
    /**
    * 
    */
    'n': number;
    /**
    * 
    */
    'n-cmts': number;
    /**
    * 
    */
    'pca': any;
    /**
    * 
    */
    'repness': any;
    'user-vote-counts': Array<Array<number>>;
    /**
    * 
    */
    'votes-base': any;
}

/**
* Data vectors. (Think of them as columns.)
*/
export class PTPTStatsVectors {
    'pid': Array<number>;
    'gid': Array<number>;
    'n-votes': Array<number>;
    'centricness': Array<number>;
    'coreness': Array<number>;
    'extremeness': Array<number>;
}

/**
* A vote object
*/
export class VoteRequestBody {
    'agid': number;
    'conversationId': string;
    'pid': VoteRequestBody.PidEnum;
    /**
    * Topic ID?
    */
    'tid': number;
    'vote': number;
}

export namespace VoteRequestBody {
    export enum PidEnum {
        Mypid = <any> 'mypid'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum CommentsApiApiKeys {
    api_key,
}

export class CommentsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CommentsApiApiKeys, value: string) {
        this.authentications[CommentsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     */
    public commentsFamousGet () : Promise<{ response: http.ClientResponse; body: { [key: string]: FamousVoterModel; };  }> {
        const localVarPath = this.basePath + '/comments/famous';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: { [key: string]: FamousVoterModel; };  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public nextCommentGet () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/nextComment';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConversationsApiApiKeys {
    api_key,
}

export class ConversationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ConversationsApiApiKeys, value: string) {
        this.authentications[ConversationsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param conversationId 
     */
    public conversationsConversationIdConversationStatsGet (conversationId: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/conversationStats'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsConversationIdConversationStatsGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param conversationId 
     * @param lastVoteTimestamp Milliseconds since Unix epoch.
     */
    public conversationsConversationIdMathPca2Get (conversationId: string, lastVoteTimestamp?: number) : Promise<{ response: http.ClientResponse; body: PCA2Response;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/math/pca2'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsConversationIdMathPca2Get.');
        }

        if (lastVoteTimestamp !== undefined) {
            queryParameters['lastVoteTimestamp'] = lastVoteTimestamp;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PCA2Response;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get all the data for conversation participants
     * @param conversationId 
     */
    public conversationsConversationIdParticipantsGet (conversationId: string) : Promise<{ response: http.ClientResponse; body: ConversationParticipants;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/participants'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsConversationIdParticipantsGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ConversationParticipants;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get participation data for one conversation
     * 
     * @param conversationId 
     */
    public conversationsConversationIdParticipationGet (conversationId: string) : Promise<{ response: http.ClientResponse; body: { [key: string]: ConversationParticipantStats; };  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/participation'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsConversationIdParticipationGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: { [key: string]: ConversationParticipantStats; };  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param conversationId 
     * @param comment Comment object that needs to be added.
     */
    public createComment (conversationId: string, comment: CommentRequestBody) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/comments'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling createComment.');
        }

        // verify required parameter 'comment' is not null or undefined
        if (comment === null || comment === undefined) {
            throw new Error('Required parameter comment was null or undefined when calling createComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: comment,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Create a new conversation
     * @param topic 
     * @param description 
     * @param shortUrl will return an easily typeable shortlink
     * @param strictModeration 
     */
    public createConversation (topic?: string, description?: string, shortUrl?: boolean, strictModeration?: boolean) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/conversations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        if (topic !== undefined) {
            formParams['topic'] = topic;
        }

        if (description !== undefined) {
            formParams['description'] = description;
        }

        if (shortUrl !== undefined) {
            formParams['short_url'] = shortUrl;
        }

        if (strictModeration !== undefined) {
            formParams['strict_moderation'] = strictModeration;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get listing of all conversations
     * 
     * @param userId Numeric ID of conversation owner/participant.
     * @param limit Unlimited result set if not specified.
     */
    public getAllConversations (userId?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: Array<ConversationModel>;  }> {
        const localVarPath = this.basePath + '/conversations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ConversationModel>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param conversationId 
     * @param includeSocial 
     * @param gid 
     * @param moderation 
     */
    public getComment (conversationId: string, includeSocial?: boolean, gid?: number, moderation?: boolean) : Promise<{ response: http.ClientResponse; body: Array<CommentModel>;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}/comments'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling getComment.');
        }

        if (includeSocial !== undefined) {
            queryParameters['include_social'] = includeSocial;
        }

        if (gid !== undefined) {
            queryParameters['gid'] = gid;
        }

        if (moderation !== undefined) {
            queryParameters['moderation'] = moderation;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CommentModel>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the data for one conversation
     * If you don&#39;t supply a &#x60;user_id&#x60;, the URLs returned will not allow you to map the participants who follow the URLs back to users of your system.
     * @param conversationId 
     * @param userId 
     */
    public getConversation (conversationId: string, userId?: string) : Promise<{ response: http.ClientResponse; body: ConversationModel;  }> {
        const localVarPath = this.basePath + '/conversations/{conversation_id}'
            .replace('{' + 'conversation_id' + '}', String(conversationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
            throw new Error('Required parameter conversationId was null or undefined when calling getConversation.');
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ConversationModel;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MetricsApiApiKeys {
    api_key,
}

export class MetricsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MetricsApiApiKeys, value: string) {
        this.authentications[MetricsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     */
    public metricsPost () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/metrics';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VotesApiApiKeys {
    api_key,
}

export class VotesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: VotesApiApiKeys, value: string) {
        this.authentications[VotesApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * Submit vote data.
     * @param body Vote object that needs to be added.
     */
    public votesPost (body: VoteRequestBody) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/votes';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling votesPost.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
